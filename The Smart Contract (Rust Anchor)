use anchor_lang::prelude::*;

// REPLACE WITH YOUR PROGRAM ID AFTER FIRST DEPLOY
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod beast_index_arena {
    use super::*;

    // 1. Initialize the Arena
    [cite_start]// Sets up 4 creatures with identical stats[cite: 15].
    pub fn initialize_game(ctx: Context<InitializeGame>) -> Result<()> {
        let game = &mut ctx.accounts.game_account;
        game.turn = 0;
        game.total_pot = 0;
        game.status = GameStatus::Active;
        game.last_timestamp = Clock::get()?.unix_timestamp;
        
        [cite_start]// Initialize 4 creatures with identical stats [cite: 15]
        for i in 0..4 {
            game.creatures[i] = Creature {
                id: i as u8,
                [cite_start]hp: 100,      // [cite: 19]
                [cite_start]atk: 15,      // [cite: 16]
                [cite_start]def: 5,       // [cite: 17]
                [cite_start]spd: 10,      // [cite: 18]
                is_alive: true,
                [cite_start]total_bets: 0, // Parimutuel pool for this creature [cite: 52]
            };
        }
        Ok(())
    }

    // 2. Place Bet (Parimutuel Market)
    // Players buy "Victory Shares". [cite_start]Market reacts, never interferes[cite: 5, 53].
    pub fn place_bet(ctx: Context<PlaceBet>, creature_idx: u8, amount: u64) -> Result<()> {
        let game = &mut ctx.accounts.game_account;
        require!(game.status == GameStatus::Active, GameError::GameEnded);
        
        let creature = &mut game.creatures[creature_idx as usize];
        require!(creature.is_alive, GameError::CreatureDead);

        // Update pools
        game.total_pot += amount;
        creature.total_bets += amount;

        // In a real app, transfer SOL from user to PDA here.
        // ctx.accounts.transfer_sol_logic()...

        Ok(())
    }

    // 3. Execute Turn (The Crank)
    [cite_start]// Runs automatically every X minutes/seconds[cite: 23].
    pub fn execute_turn(ctx: Context<ExecuteTurn>) -> Result<()> {
        let game = &mut ctx.accounts.game_account;
        require!(game.status == GameStatus::Active, GameError::GameEnded);

        // --- SIMPLE RNG (HACKATHON ONLY) ---
        [cite_start]// Using block timestamp for randomness [cite: 24, 26]
        let clock = Clock::get()?;
        let seed = clock.unix_timestamp as u64; 
        
        // Pseudo-random selection of attacker and target
        let attacker_idx = (seed % 4) as usize; 
        let target_idx = ((seed / 7) % 4) as usize; 

        // --- BATTLE LOGIC ---
        // Verify both are alive
        if game.creatures[attacker_idx].is_alive && game.creatures[target_idx].is_alive && attacker_idx != target_idx {
            let attacker = &game.creatures[attacker_idx];
            let target = &mut game.creatures[target_idx];

            [cite_start]// Damage Calculation: max(1, ATK - DEF) [cite: 31]
            let damage = if attacker.atk > target.def {
                attacker.atk - target.def
            } else {
                1
            };

            [cite_start]// HP Update [cite: 33]
            if target.hp > damage {
                target.hp -= damage;
            } else {
                target.hp = 0;
                target.is_alive = false; [cite_start]// Elimination [cite: 35]
            }

            [cite_start]// Emit Event for Frontend Logs [cite: 42]
            emit!(TurnEvent {
                turn: game.turn,
                attacker: attacker_idx as u8,
                target: target_idx as u8,
                damage: damage,
                target_hp: target.hp,
            });
        }

        // --- END CONDITION ---
        [cite_start]// Check if only one remains [cite: 37]
        let alive_count = game.creatures.iter().filter(|c| c.is_alive).count();
        if alive_count <= 1 {
            game.status = GameStatus::Ended;
        }

        game.turn += 1;
        game.last_timestamp = clock.unix_timestamp;
        Ok(())
    }
}

// --- DATA STRUCTURES ---

#[account]
pub struct GameAccount {
    pub turn: u64,
    pub total_pot: u64,
    pub status: GameStatus,
    pub last_timestamp: i64,
    pub creatures: [Creature; 4],
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]
pub enum GameStatus {
    Active,
    Ended,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Default)]
pub struct Creature {
    pub id: u8,
    pub hp: u16,
    pub atk: u16,
    pub def: u16,
    pub spd: u16,
    pub is_alive: bool,
    pub total_bets: u64,
}

#[event]
pub struct TurnEvent {
    pub turn: u64,
    pub attacker: u8,
    pub target: u8,
    pub damage: u16,
    pub target_hp: u16,
}

#[error_code]
pub enum GameError {
    #[msg("Game has ended.")]
    GameEnded,
    #[msg("Creature is dead.")]
    CreatureDead,
}

#[derive(Accounts)]
pub struct InitializeGame<'info> {
    #[account(init, payer = user, space = 8 + 500)] 
    pub game_account: Account<'info, GameAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct PlaceBet<'info> {
    #[account(mut)]
    pub game_account: Account<'info, GameAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteTurn<'info> {
    #[account(mut)]
    pub game_account: Account<'info, GameAccount>,
}
